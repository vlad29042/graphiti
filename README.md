# Форк Graphiti с поддержкой relevance score

## Зачем этот форк?

Этот форк добавляет возможность получения relevance score (оценки релевантности) в результатах поиска Graphiti.

### Проблема
Оригинальный Graphiti вычисляет score внутри Neo4j запросов, но не возвращает его в результатах. Это ограничивает возможности фильтрации результатов по релевантности.

### Решение
Добавлена поддержка передачи score из Neo4j в результаты поиска.

### Связанный проект
Этот форк используется в [graphiti-api](https://github.com/vlad29042/graphiti-api) - Production-ready HTTP API обёртке для Graphiti, которая решает проблемы event loop conflicts и добавляет:
- RESTful HTTP endpoints
- n8n совместимость
- Фильтрацию по relevance score


## Использование

```python
# Теперь результаты поиска содержат score
results = await graphiti.search("query", group_ids=["id"])
for edge in results:
    print(f"Fact: {edge.fact}, Score: {edge.score}")
```

## Установка

```bash
pip install git+https://github.com/vlad29042/graphiti.git@main
```

---

<p align="center">
  <a href="https://www.getzep.com/">
    <img src="https://github.com/user-attachments/assets/119c5682-9654-4257-8922-56b7cb8ffd73" width="150" alt="Zep Logo">
  </a>
</p>

<h1 align="center">
Graphiti
</h1>
<h2 align="center">Создавайте графы знаний реального времени для AI агентов</h2>
<div align="center">

[![Lint](https://github.com/getzep/Graphiti/actions/workflows/lint.yml/badge.svg?style=flat)](https://github.com/getzep/Graphiti/actions/workflows/lint.yml)
[![Unit Tests](https://github.com/getzep/Graphiti/actions/workflows/unit_tests.yml/badge.svg)](https://github.com/getzep/Graphiti/actions/workflows/unit_tests.yml)
[![MyPy Check](https://github.com/getzep/Graphiti/actions/workflows/typecheck.yml/badge.svg)](https://github.com/getzep/Graphiti/actions/workflows/typecheck.yml)

![GitHub Repo stars](https://img.shields.io/github/stars/getzep/graphiti)
[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?&logo=discord&logoColor=white)](https://discord.com/invite/W8Kw6bsgXQ)
[![arXiv](https://img.shields.io/badge/arXiv-2501.13956-b31b1b.svg?style=flat)](https://arxiv.org/abs/2501.13956)
[![Release](https://img.shields.io/github/v/release/getzep/graphiti?style=flat&label=Release&color=limegreen)](https://github.com/getzep/graphiti/releases)

</div>
<div align="center">

<a href="https://trendshift.io/repositories/12986" target="_blank"><img src="https://trendshift.io/api/badge/repositories/12986" alt="getzep%2Fgraphiti | Trendshift" style="width: 250px; height: 55px;" width="250" height="55"/></a>

</div>

:star: _Помогите нам привлечь больше разработчиков и развить сообщество Graphiti. Поставьте звезду этому репозиторию!_

<br />

> [!TIP]
> Посмотрите новый [MCP сервер для Graphiti](mcp_server/README.md)! Дайте Claude, Cursor и другим MCP клиентам мощную память на основе графов знаний.

Graphiti — это фреймворк для построения и запросов к временным графам знаний, специально разработанный для AI агентов, работающих в динамических средах. В отличие от традиционных методов RAG (Retrieval-Augmented Generation), Graphiti непрерывно интегрирует пользовательские взаимодействия, структурированные и неструктурированные корпоративные данные, а также внешнюю информацию в единый, запрашиваемый граф. Фреймворк поддерживает инкрементальные обновления данных, эффективный поиск и точные исторические запросы без необходимости полного пересчёта графа, что делает его подходящим для разработки интерактивных, контекстно-зависимых AI приложений.

Используйте Graphiti для:

- Интеграции и поддержания динамических пользовательских взаимодействий и бизнес-данных
- Облегчения рассуждений на основе состояний и автоматизации задач для агентов
- Запросов к сложным, развивающимся данным с помощью семантических, ключевых слов и графовых методов поиска

<br />

<p align="center">
    <img src="images/graphiti-graph-intro.gif" alt="Graphiti temporal walkthrough" width="700px">   
</p>

<br />

Граф знаний — это сеть взаимосвязанных фактов, таких как _"Кендра любит кроссовки Adidas."_ Каждый факт — это "триплет", представленный двумя сущностями или узлами ("Кендра", "кроссовки Adidas") и их отношением или ребром ("любит"). Графы знаний широко исследовались для информационного поиска. Что делает Graphiti уникальным — это его способность автономно строить граф знаний, обрабатывая изменяющиеся отношения и поддерживая исторический контекст.

## Graphiti и платформа контекстной инженерии Zep

Graphiti является основой [Zep](https://www.getzep.com) — готовой платформы контекстной инженерии для AI агентов. Zep предлагает память агентов, Graph RAG для динамических данных, а также извлечение и сборку контекста.

Используя Graphiti, мы продемонстрировали, что Zep является [передовым решением в области памяти агентов](https://blog.getzep.com/state-of-the-art-agent-memory/).

Прочитайте нашу статью: [Zep: Архитектура временного графа знаний для памяти агентов](https://arxiv.org/abs/2501.13956).

Мы рады открыть исходный код Graphiti, веря, что его потенциал выходит далеко за рамки приложений AI памяти.

<p align="center">
    <a href="https://arxiv.org/abs/2501.13956"><img src="images/arxiv-screenshot.png" alt="Zep: A Temporal Knowledge Graph Architecture for Agent Memory" width="700px"></a>
</p>

## Почему Graphiti?

Традиционные подходы RAG часто полагаются на пакетную обработку и статическое обобщение данных, что делает их неэффективными для часто изменяющихся данных. Graphiti решает эти проблемы, предоставляя:

- **Инкрементальные обновления в реальном времени:** Немедленная интеграция новых эпизодов данных без пакетного пересчёта
- **Битемпоральная модель данных:** Явное отслеживание времени возникновения событий и времени их внесения, позволяющее точные запросы на момент времени
- **Эффективный гибридный поиск:** Комбинирует семантические эмбеддинги, ключевые слова (BM25) и обход графа для достижения запросов с низкой задержкой без зависимости от обобщения LLM
- **Пользовательские определения сущностей:** Гибкое создание онтологий и поддержка определённых разработчиком сущностей через простые модели Pydantic
- **Масштабируемость:** Эффективно управляет большими наборами данных с параллельной обработкой, подходит для корпоративных сред

<p align="center">
    <img src="/images/graphiti-intro-slides-stock-2.gif" alt="Graphiti structured + unstructured demo" width="700px">   
</p>

## Graphiti vs. GraphRAG

| Аспект                     | GraphRAG                              | Graphiti                                         |
| -------------------------- | ------------------------------------- | ------------------------------------------------ |
| **Основное применение**    | Статическое обобщение документов      | Управление динамическими данными                 |
| **Обработка данных**       | Пакетная обработка                    | Непрерывные, инкрементальные обновления          |
| **Структура знаний**       | Кластеры сущностей и обобщения сообществ | Эпизодические данные, семантические сущности, сообщества |
| **Метод поиска**           | Последовательное обобщение LLM        | Гибридный семантический, ключевой и графовый поиск |
| **Адаптивность**           | Низкая                                | Высокая                                          |
| **Обработка времени**      | Базовое отслеживание временных меток  | Явное битемпоральное отслеживание               |
| **Обработка противоречий** | Суждения на основе обобщения LLM      | Временная инвалидация рёбер                      |
| **Задержка запросов**      | Секунды до десятков секунд            | Обычно субсекундная задержка                     |
| **Пользовательские типы**  | Нет                                   | Да, настраиваемые                                |
| **Масштабируемость**       | Умеренная                             | Высокая, оптимизирована для больших наборов данных |

Graphiti специально разработан для решения проблем динамических и часто обновляемых наборов данных, что делает его особенно подходящим для приложений, требующих взаимодействия в реальном времени и точных исторических запросов.

## Установка

Требования:

- Python 3.10 или выше
- Neo4j 5.26 / FalkorDB 1.1.2 или выше (служит бэкендом для хранения эмбеддингов)
- OpenAI API ключ (Graphiti по умолчанию использует OpenAI для LLM вывода и эмбеддингов)

> [!IMPORTANT]
> Graphiti лучше всего работает с LLM сервисами, поддерживающими структурированный вывод (такими как OpenAI и Gemini).
> Использование других сервисов может привести к неправильным схемам вывода и сбоям при загрузке данных. Это особенно
> проблематично при использовании небольших моделей.

Опционально:

- Google Gemini, Anthropic или Groq API ключ (для альтернативных LLM провайдеров)

> [!TIP]
> Самый простой способ установить Neo4j — через [Neo4j Desktop](https://neo4j.com/download/). Он предоставляет удобный
> интерфейс для управления экземплярами и базами данных Neo4j.
> Альтернативно, вы можете использовать FalkorDB локально через Docker и сразу начать с примера быстрого старта:

```bash
docker run -p 6379:6379 -p 3000:3000 -it --rm falkordb/falkordb:latest
```

```bash
pip install graphiti-core
```

или

```bash
uv add graphiti-core
```

### Установка с поддержкой FalkorDB

Если вы планируете использовать FalkorDB в качестве бэкенда графовой базы данных, установите с дополнением FalkorDB:

```bash
pip install graphiti-core[falkordb]

# или с uv
uv add graphiti-core[falkordb]
```

### Вы также можете установить опциональных LLM провайдеров как дополнения:

```bash
# Установка с поддержкой Anthropic
pip install graphiti-core[anthropic]

# Установка с поддержкой Groq
pip install graphiti-core[groq]

# Установка с поддержкой Google Gemini
pip install graphiti-core[google-genai]

# Установка с несколькими провайдерами
pip install graphiti-core[anthropic,groq,google-genai]

# Установка с FalkorDB и LLM провайдерами
pip install graphiti-core[falkordb,anthropic,google-genai]
```

## Низкая параллельность по умолчанию; ошибки лимита скорости 429 LLM провайдера

Конвейеры загрузки данных Graphiti разработаны для высокой параллельности. По умолчанию параллельность установлена на низком уровне, чтобы избежать ошибок лимита скорости 429 от LLM провайдера. Если вы находите Graphiti медленным, пожалуйста, увеличьте параллельность, как описано ниже.

Параллельность контролируется переменной окружения `SEMAPHORE_LIMIT`. По умолчанию `SEMAPHORE_LIMIT` установлен на `10` параллельных операций, чтобы помочь предотвратить ошибки лимита скорости `429` от вашего LLM провайдера. Если вы сталкиваетесь с такими ошибками, попробуйте уменьшить это значение.

Если ваш LLM провайдер позволяет более высокую пропускную способность, вы можете увеличить `SEMAPHORE_LIMIT` для повышения производительности загрузки эпизодов.

## Быстрый старт

> [!IMPORTANT]
> Graphiti по умолчанию использует OpenAI для LLM вывода и эмбеддингов. Убедитесь, что `OPENAI_API_KEY` установлен в вашем окружении.
> Также доступна поддержка Anthropic и Groq для LLM выводов. Другие LLM провайдеры могут поддерживаться через OpenAI
> совместимые API.

Для полного рабочего примера смотрите [Пример быстрого старта](./examples/quickstart/README.md) в директории примеров. Быстрый старт демонстрирует:

1. Подключение к базе данных Neo4j или FalkorDB
2. Инициализация индексов и ограничений Graphiti
3. Добавление эпизодов в граф (как текст, так и структурированный JSON)
4. Поиск отношений (рёбер) с использованием гибридного поиска
5. Переранжирование результатов поиска с использованием графового расстояния
6. Поиск узлов с использованием предопределённых рецептов поиска

Пример полностью документирован с чёткими объяснениями каждой функциональности и включает всеобъемлющий README с инструкциями по настройке и следующими шагами.

## MCP сервер

Директория `mcp_server` содержит реализацию Model Context Protocol (MCP) сервера для Graphiti. Этот сервер позволяет AI ассистентам взаимодействовать с возможностями графа знаний Graphiti через протокол MCP.

Ключевые особенности MCP сервера включают:

- Управление эпизодами (добавление, извлечение, удаление)
- Управление сущностями и обработка отношений
- Возможности семантического и гибридного поиска
- Управление группами для организации связанных данных
- Операции обслуживания графа

MCP сервер может быть развёрнут с использованием Docker с Neo4j, что упрощает интеграцию Graphiti в рабочие процессы ваших AI ассистентов.

Для подробных инструкций по настройке и примеров использования смотрите [README MCP сервера](./mcp_server/README.md).

## REST сервис

Директория `server` содержит API сервис для взаимодействия с Graphiti API. Он построен с использованием FastAPI.

Пожалуйста, смотрите [README сервера](./server/README.md) для получения дополнительной информации.

## Опциональные переменные окружения

В дополнение к учётным данным Neo4j и OpenAI-совместимым, Graphiti также имеет несколько опциональных переменных окружения.
Если вы используете одну из наших поддерживаемых моделей, такую как модели Anthropic или Voyage, необходимые переменные окружения
должны быть установлены.

### Конфигурация базы данных

Имена баз данных настраиваются непосредственно в конструкторах драйверов:

- **Neo4j**: Имя базы данных по умолчанию `neo4j` (жёстко закодировано в Neo4jDriver)
- **FalkorDB**: Имя базы данных по умолчанию `default_db` (жёстко закодировано в FalkorDriver)

Начиная с версии v0.17.0, если вам нужно настроить конфигурацию базы данных, вы можете создать экземпляр драйвера базы данных и передать его в конструктор Graphiti с помощью параметра `graph_driver`.

## Документация

- [Руководства и документация API](https://help.getzep.com/graphiti)
- [Быстрый старт](https://help.getzep.com/graphiti/graphiti/quick-start)
- [Создание агента с LangChain's LangGraph и Graphiti](https://help.getzep.com/graphiti/graphiti/lang-graph-agent)

## Телеметрия

Graphiti собирает анонимную статистику использования, чтобы помочь нам понять, как используется фреймворк, и улучшить его для всех. Мы считаем, что прозрачность важна, поэтому вот что именно мы собираем и почему.

### Что мы собираем

Когда вы инициализируете экземпляр Graphiti, мы собираем:

- **Анонимный идентификатор**: Случайно сгенерированный UUID, хранящийся локально в `~/.cache/graphiti/telemetry_anon_id`
- **Информация о системе**: Операционная система, версия Python и архитектура системы
- **Версия Graphiti**: Используемая вами версия
- **Выбор конфигурации**:
  - Тип LLM провайдера (OpenAI, Azure, Anthropic и т.д.)
  - База данных бэкенда (Neo4j, FalkorDB)
  - Провайдер эмбеддеров (OpenAI, Azure, Voyage и т.д.)

### Что мы НЕ собираем

Мы привержены защите вашей конфиденциальности. Мы **никогда** не собираем:

- Личную информацию или идентификаторы
- API ключи или учётные данные
- Ваши фактические данные, запросы или содержимое графа
- IP-адреса или имена хостов
- Пути к файлам или системно-специфичную информацию
- Любое содержимое из ваших эпизодов, узлов или рёбер

### Зачем мы собираем эти данные

Эта информация помогает нам:

- Понимать, какие конфигурации наиболее популярны, чтобы приоритизировать поддержку и тестирование
- Определять, на каких LLM и провайдерах баз данных сосредоточить усилия по разработке
- Отслеживать паттерны принятия для управления нашей дорожной картой
- Обеспечивать совместимость между различными версиями Python и операционными системами

Делясь этой анонимной информацией, вы помогаете нам сделать Graphiti лучше для всех в сообществе.

### Просмотр кода телеметрии

Код телеметрии [можно найти здесь](graphiti_core/telemetry/telemetry.py).

### Как отключить телеметрию

Телеметрия работает по принципу **opt-out** и может быть отключена в любое время. Чтобы отключить сбор телеметрии:

**Вариант 1: Переменная окружения**

```bash
export GRAPHITI_TELEMETRY_ENABLED=false
```

**Вариант 2: Установка в профиле оболочки**

```bash
# Для пользователей bash (~/.bashrc или ~/.bash_profile)
echo 'export GRAPHITI_TELEMETRY_ENABLED=false' >> ~/.bashrc

# Для пользователей zsh (~/.zshrc)
echo 'export GRAPHITI_TELEMETRY_ENABLED=false' >> ~/.zshrc
```

**Вариант 3: Установка для конкретной сессии Python**

```python
import os
os.environ['GRAPHITI_TELEMETRY_ENABLED'] = 'false'

# Затем инициализируйте Graphiti как обычно
from graphiti_core import Graphiti
graphiti = Graphiti(...)
```

Телеметрия автоматически отключается во время тестовых запусков (когда обнаружен `pytest`).

## Статус и дорожная карта

Graphiti находится в активной разработке. Мы стремимся поддерживать стабильность API, работая над:

- [x] Поддержка пользовательских схем графов:
  - Позволить разработчикам предоставлять свои собственные определённые классы узлов и рёбер при загрузке эпизодов
  - Включить более гибкое представление знаний, адаптированное к конкретным случаям использования
- [x] Улучшение возможностей поиска с более надёжными и настраиваемыми опциями
- [x] Graphiti MCP сервер
- [ ] Расширение тестового покрытия для обеспечения надёжности и выявления граничных случаев

## Участие

Мы поощряем и ценим все формы вклада, будь то код, документация, решение проблем GitHub или
ответы на вопросы в канале Graphiti Discord. Для подробных руководств по вкладу кода, пожалуйста, обратитесь
к [CONTRIBUTING](CONTRIBUTING.md).

## Поддержка

Присоединяйтесь к [Zep Discord серверу](https://discord.com/invite/W8Kw6bsgXQ) и перейдите в канал **#Graphiti**!